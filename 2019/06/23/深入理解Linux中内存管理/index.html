<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="gagapencil">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="gagapencil">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="android开发 学习 工作 生活">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>深入理解linux中内存管理 · gagapencil学习小站</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">gagapencil学习小站</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">深入理解linux中内存管理</a>
            </div>
    </div>
    
    <a class="home-link" href="/">gagapencil学习小站</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            深入理解linux中内存管理
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="linux 虚拟内存 内存管理 c内存模型">linux 虚拟内存 内存管理 c内存模型</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">6.8k</span>阅读时长: <span class="post-count reading-time">23 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/06/23</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>[TOC]</p>
<p>##前言<br>c程序运行在linux进程中，要想弄清楚c程序运行时内存需要搞清楚进程空间，而要搞清楚进程空间 虚拟内存是必须要了解的。毋庸置疑，虚拟内存绝对是操作系统中最重要的概念之一。我想主要是由于内存的重要”战略地位”。CPU太快，但容量小且功能单一，其他 I/O 硬件支持各种花式功能，可是相对于 CPU，它们又太慢。于是它们之间就需要一种润滑剂来作为缓冲，这就是内存大显身手的地方。而在现代操作系统中，多任务已是标配。多任务并行，大大提升了 CPU 利用率，但却引出了多个进程对内存操作的冲突问题，虚拟内存概念的提出就是为了解决这个问题。</p>
<h2 id="由来："><a href="#由来：" class="headerlink" title="由来："></a>由来：</h2><p>回顾一下历史，在早期的计算机中，程序是直接运行在物理内存上的。换句话说，就是程序在运行的过程中访问的都是物理地址。如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为内存管理。举一个早期的计算机系统中，内存分配管理的例子，以便于理解。</p>
<p>假如我们有三个程序，程序A，B，C，程序A运行的过程中需要10M内存，程序B运行的过程中需要100M内存，而程序C运行的过程中需要20M内存。如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A，接下来的10M-110M分配给B。这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。<br>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>这种内存管理方式存在的几个比较明显的问题。</p>
<ul>
<li>进程地址空间不能隔离，由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以访问系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举地破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</li>
<li>内存使用的效率低，如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。　</li>
<li>程序运行的地址不能确定。程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址。</li>
</ul>
<p>内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？引用计算机界一句无从考证的名言：“计算机系统里的任何问题都可以靠引入一个中间层来解决。”现在的内存管理方法就是在程序和物理内存之间引入了<strong>虚拟内存</strong>这个概念。 </p>
<ol>
<li>虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。</li>
<li>每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。</li>
<li>顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</li>
</ol>
<h2 id="虚拟内存机制"><a href="#虚拟内存机制" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h2><p>虚拟内存的实现主要通过分页机制，早期是通过分段</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>这种方法是人们最开始使用的一种方法，基本思路是将程序<strong>所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间</strong>。
<img src="https://i.imgur.com/zrfaQUM.jpg" alt></p>
<p>这种<strong>分段的机制解决了开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题,但是对于内存效率问题仍然无能为力</strong>。</p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。那么，怎么才算高效率的内存使用呢。事实上，根据程序的局部性运行原理，<strong>一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到</strong>。所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><p><strong>分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率</strong>。</p>
<p>试想一下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。</p>
<p>如果分的太小了也不行。我们知道系统里的基本单位都是 Byte 字节，如果将每一个虚拟内存的 Byte 都对应到物理内存的地址，每个条目最少需要 8字节（32位虚拟地址-&gt;32位物理地址），在 4G 内存的情况下，就需要 32GB 的空间来存放对照表，那么这张表就大得真正的物理地址也放不下了，于是操作系统引入了 页（Page）的概念。</p>
<p><strong>Linux中一般页的大小是4KB</strong>，我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：<br><img src="https://i.imgur.com/I8yWM7Y.jpg" alt></p>
<p>可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行)，甚至他们共用了一部分物理地址空间，这就是共享内存。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个缺页异常，然后异常管理程序会将其读到内存中。</p>
<p>这就是分页机制的原理，当然Linux中的分页机制的实现还是比较复杂的，通过了页全局目录，页上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<strong>MMU(Memory Management Unit)</strong>，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p>###SWAP<br>我们前文提到了虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，如果所有的物理内存都被占用了怎么办呢？</p>
<p>Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。</p>
<h2 id="进程虚拟地址空间分布"><a href="#进程虚拟地址空间分布" class="headerlink" title="进程虚拟地址空间分布"></a>进程虚拟地址空间分布</h2><p>在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间(Virtual Address Space)，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<p>虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。<br>Linux进程在虚拟内存中的标准内存段布局如下图所示：</p>
<p><img src="https://i.imgur.com/5S2Pb4o.jpg" alt></p>
<p>其中，用户地址空间中的蓝色条带对应于映射到物理内存的不同内存段，灰白区域表示未映射的部分。这些段只是简单的内存地址范围，与Intel处理器的段没有关系。</p>
<p>用户进程部分分段存储内容如下表所示(按地址递减顺序)：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>局部变量、函数参数、返回地址等</td>
</tr>
<tr>
<td>堆</td>
<td>动态分配的内存</td>
</tr>
<tr>
<td>BSS段</td>
<td>未初始化或初值为0的全局变量和静态局部变量</td>
</tr>
<tr>
<td>数据段</td>
<td>已初始化且初值非0的全局变量和静态局部变量</td>
</tr>
<tr>
<td>代码段</td>
<td>可执行代码、字符串字面值、只读变量</td>
</tr>
<tr>
<td>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</td>
<td></td>
</tr>
</tbody></table>
<p>以下详细介绍各个分段的含义。</p>
<h3 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h3><p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。</li>
</ul>
<p>持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再收缩。</p>
<p>Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。</p>
<p>堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。</p>
<p>堆栈的大小在运行时由内核动态调整。</p>
<h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>BSS(Block Started by Symbol)段中通常存放程序中以下符号：</p>
<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li>
<li>未定义且初值不为0的符号(该初值即common block的大小)</li>
</ul>
<h3 id="数据段-Data"><a href="#数据段-Data" class="headerlink" title="数据段(Data)"></a>数据段(Data)</h3><p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p>
<p>数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p>
<p>数据段与BSS段的区别如下： </p>
<ol>
<li>BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</li>
<li>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</li>
<li>运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。</li>
</ol>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(text)"></a>代码段(text)</h3><p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p>代码段最容易受优化措施影响。</p>
<h2 id="系统调用与内存管理（sbrk、brk、mmap、munmap）"><a href="#系统调用与内存管理（sbrk、brk、mmap、munmap）" class="headerlink" title="系统调用与内存管理（sbrk、brk、mmap、munmap）"></a>系统调用与内存管理（sbrk、brk、mmap、munmap）</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>在Linux中，4G内存可分为两部分——内核空间1G（3<del>4G）与用户空间3G（0</del>3G）,我们通常写的C代码都是在对用户空间即0~3G的内存进行操作。而且，用户空间的代码不能直接访问内核空间，因此内核空间提供了一系列的函数，实现用户空间进入内核空间的接口，这一系列的函数称为系统调用（System Call）。比如我们经常使用的open、close、read、write等函数都是系统级别的函数（man 2 function_name），而像fopen、fclose、fread、fwrite等都是用户级别的函数（man 3 function_name）。不同级别的函数能够操作的内存区域自然也就不同。</p>
<p>我们用一幅图来描述函数的调用过程：<br><img src="https://i.imgur.com/pFzUv6M.png" alt></p>
<p>对于C++中new与delete的底层则是用malloc和free实现。而我们所用的malloc()、free()与内核之间的接口（桥梁）就是sbrk()等系统函数；当然我们也可以直接调用系统调用（系统函数）,达到同样的作用。我们可以用下面这幅图来描述基本内存相关操作之间的关系：</p>
<p><img src="https://i.imgur.com/fGklicu.png" alt></p>
<p>虽然使用系统调用会带来一定的好处，但是物极必反，系统调用并非能频繁使用。由于程序由用户进入内核层时，会将用户层的状态先封存起来，然后到内核层运行代码，运行结束以后，从内核层出来到用户层时，再把数据加载回来。因此，频繁的系统调用效率很低。今天我们就系统调用层面来对内存操作做进一步的了解。</p>
<h3 id="内存管理（Memory-Management）系统调用"><a href="#内存管理（Memory-Management）系统调用" class="headerlink" title="内存管理（Memory Management）系统调用"></a>内存管理（Memory Management）系统调用</h3><h4 id="brk-与sbrk"><a href="#brk-与sbrk" class="headerlink" title="brk()与sbrk()"></a>brk()与sbrk()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//函数原型：</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int brk(void * addr); </span><br><span class="line">void * sbrk(intptr_t increment);</span><br></pre></td></tr></table></figure>

<h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><p>brk()和sbrk()改变程序间断点的位置。程序间断点就是程序数据段的结尾。（程序间断点是为初始化数据段的起始位置）.通过增加程序间断点进程可以更有效的申请内存 。当addr参数合理、系统有足够的内存并且不超过最大值时brk()函数将数据段结尾设置为addr,即间断点设置为addr。sbrk()将程序数据空间增加increment字节。当increment为0时则返回程序间断点的当前位置。</p>
<h5 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h5><p>brk()成功返回0，失败返回-1并且设置errno值为ENOMEM（注：在mmap中会提到）。<br>sbrk()成功返回之前的程序间断点地址。如果间断点值增加，那么这个指针（指的是返回的之前的间断点地址）是指向分配的新的内存的首地址。如果出错失败，就返回一个指针并设置errno全局变量的值为ENOMEM。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>这两个函数都用来改变 “program break” (程序间断点)的位置，改变数据段长度（Change data segment size），实现虚拟内存到物理内存的映射。<br>brk()函数直接修改有效访问范围的末尾地址实现分配与回收。sbrk()参数函数中：当increment为正值时，间断点位置向后移动increment字节。同时返回移动之前的位置，相当于分配内存。当increment为负值时，位置向前移动increment字节，相当与于释放内存，其返回值没有实际意义。当increment为0时，不移动位置只返回当前位置。参数increment的符号决定了是分配还是回收内存。而关于program break的位置如图所示：<br><img src="https://i.imgur.com/oXUOGbd.jpg" alt></p>
<h5 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h5><p>对于分配好的内存，我们只要有其首地址old与长度MAX*MAX即可不越界的准确使用（如下图所示），其效果与malloc相同，只不过sbrk()与brk()是C标准函数的底层实现而已，其机制较为复杂（测试中，死循环是为了查看maps文件，不至于进程消亡文件随之消失）。<br><img src="https://i.imgur.com/YYwqRwk.png" alt></p>
<p>虽然，sbrk()与brk()均可分配回收兼职，但是我们一般用sbrk()分配内存，而用brk()回收内存，上例中回收内存可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int err = brk(old);</span><br><span class="line">/**或者brk(p);效果与sbrk(-MAX*MAX);是一样的，但brk()更方便与清晰明了。**/</span><br><span class="line">if(-1 == err)&#123;</span><br><span class="line">    perror(&quot;brk&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、mmap-与munmap"><a href="#2、mmap-与munmap" class="headerlink" title="2、mmap()与munmap():"></a>2、mmap()与munmap():</h4><p>mmap函数（地址映射）：mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零(Linux堆空间未使用内存均清零)。这里我们只研究mmap的内存映射，而暂时不讨论文件方面的问题。关于mmap的文件映射的更详细的内容可参考认真分析mmap：<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">是什么 为什么 怎么用</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//函数原型：</span><br><span class="line">#incldue&lt;sys/mman.h&gt;</span><br><span class="line">void * mmap(void * addr, size_t length,int prot,int flags,int fd,off_t offset)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line"></span><br><span class="line">（1）、addr: </span><br><span class="line">起始地址，置零让系统自行选择并返回即可. </span><br><span class="line">（2）、length: </span><br><span class="line">长度，不够一页会自动凑够一页的整数倍，我们可以宏定义#define MIN_LENGTH_MMAP 4096为一页大小 </span><br><span class="line">（3）、prot: </span><br><span class="line">读写操作权限，PROT_READ可读、PROT_WRITE可写、PROT_EXEC可执行、PROT_NONE映射区域不能读取。（注意PROT_XXXXX与文件本身的权限不冲突，如果在程序中不设定任何权限，即使本身存在读写权限，该进程也不能对其操作） </span><br><span class="line">（4）、flags常用标志: </span><br><span class="line">①MAP_SHARED【share this mapping】、MAP_PRIVATE【Create a private copy-on-write mapping】 </span><br><span class="line">MAP_SHARED只能设置文件共享，不能地址共享，即使设置了共享，对于两个进程来说，也不会生效。而MAP_PRIVATE则对于文件与内存都可以设置为私有。 </span><br><span class="line">②MAP_ANON【Deprecated】、MAP_ANONYMOUS：匿名映射，如果映射地址需要加该参数，如果不加默认映射文件。MAP_ANON已经过时，只需使用MAP_ANONYMOUS即可 </span><br><span class="line">（5）、文件描述符：fd </span><br><span class="line">（6）、文件描述符偏移量：offset </span><br><span class="line">（fd和offset对于一般性内存分配来说设置为0即可）</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">失败返回MAP_FAILED，即(void * (-1))并设置errno全局变量。 </span><br><span class="line">成功返回指向mmap area的指针pointer。</span><br><span class="line"></span><br><span class="line">常见errno错误：</span><br><span class="line"></span><br><span class="line">①ENOMEM：内存不足； </span><br><span class="line">②EAGAIN：文件被锁住或有太多内存被锁住； </span><br><span class="line">③EBADF：参数fd不是有效的文件描述符； </span><br><span class="line">④EACCES：存在权限错误，。如果是MAP_PRIVATE情况下文件必须可读；使用MAP_SHARED则文件必须能写入，且设置prot权限必须为PROT_WRITE。 </span><br><span class="line">⑤EINVAL：参数addr、length或者offset中有不合法参数存在。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">munmap函数：解除映射关系</span><br><span class="line">int munmap(void * addr, size_t length);//addr为mmap函数返回接收的地址，length为请求分配的长度。</span><br></pre></td></tr></table></figure>

<h2 id="常用管理命令"><a href="#常用管理命令" class="headerlink" title="常用管理命令"></a>常用管理命令</h2><p>本节介绍了管理 Linux 的虚拟内存的常用命令，更多可参考：<a href="https://www.cnblogs.com/jiayy/p/3458076.html" target="_blank" rel="noopener">linux内存查看方法</a></p>
<h3 id="查看系统内存状态"><a href="#查看系统内存状态" class="headerlink" title="查看系统内存状态"></a>查看系统内存状态</h3><p>查看系统内存情况的方式有很多，free、 vmstat等命令都可输出当前系统的内存状态，需要注意的是可用内存并不只是 free 这一列，由于操作系统的 lazy 特性，大量的 buffer/cache 在进程不再使用后，不会被立即清理，如果之前使用它们的进程再次运行还可以继续使用，它们在必要时也是可以被利用的。</p>
<p>此外，通过 cat /proc/meminfo 可以查看系统内存被使用的详细情况，包括脏页状态等。详情可参见：<a href="http://linuxperf.com/?p=142" target="_blank" rel="noopener">/PROC/MEMINFO</a>之谜。</p>
<h3 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h3><p>如果想单独查看某一进程的虚拟内存分布情况，可以使用 pmap pid 命令，它会把虚拟内存各段的占用情况从低地址到高地址都列出来。</p>
<p>可以添加 -XX 参数来输出更详细的信息。</p>
<p>##参考：</p>
<p><a href="https://www.cnblogs.com/lcw/p/3505503.html" target="_blank" rel="noopener">深入理解Linux中内存管理：https://www.cnblogs.com/lcw/p/3505503.html</a></p>
<p><a href="https://zhenbianshu.github.io/2018/11/understand_virtual_memory.html" target="_blank" rel="noopener">理解 Linux 的虚拟内存：https://zhenbianshu.github.io/2018/11/understand_virtual_memory.html</a></p>
<p><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a></p>
<p><a href="https://blog.csdn.net/Apollon_krj/article/details/54565768" target="_blank" rel="noopener">系统调用与内存管理（sbrk、brk、mmap、munmap）</a></p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://hesitationpencil.github.io">gagapencil</a>
            </p><p>原文链接：<a href="https://hesitationpencil.github.io/2019/06/23/深入理解Linux中内存管理/">https://hesitationpencil.github.io/2019/06/23/深入理解Linux中内存管理/</a>
            </p><p>发表日期：<a href="https://hesitationpencil.github.io/2019/06/23/深入理解Linux中内存管理/">June 23rd 2019, 3:19:14 pm</a>
            </p><p>更新日期：<a href="https://hesitationpencil.github.io/2019/06/23/深入理解Linux中内存管理/">June 23rd 2019, 6:02:34 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/06/20/FFmpeg命令详解 /" title="FFmpeg命令详解">
                    <div class="prevTitle">FFmpeg命令详解</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:youyuqianbi@163.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/example_qr.png">
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#由来："><span class="toc-number">1.</span> <span class="toc-text">由来：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存机制"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分段"><span class="toc-number">2.1.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页机制"><span class="toc-number">2.2.</span> <span class="toc-text">分页机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程虚拟地址空间分布"><span class="toc-number">3.</span> <span class="toc-text">进程虚拟地址空间分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核空间"><span class="toc-number">3.1.</span> <span class="toc-text">内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈-stack"><span class="toc-number">3.2.</span> <span class="toc-text">栈(stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BSS段"><span class="toc-number">3.3.</span> <span class="toc-text">BSS段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据段-Data"><span class="toc-number">3.4.</span> <span class="toc-text">数据段(Data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码段-text"><span class="toc-number">3.5.</span> <span class="toc-text">代码段(text)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统调用与内存管理（sbrk、brk、mmap、munmap）"><span class="toc-number">4.</span> <span class="toc-text">系统调用与内存管理（sbrk、brk、mmap、munmap）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用"><span class="toc-number">4.1.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理（Memory-Management）系统调用"><span class="toc-number">4.2.</span> <span class="toc-text">内存管理（Memory Management）系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#brk-与sbrk"><span class="toc-number">4.2.1.</span> <span class="toc-text">brk()与sbrk()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#描述："><span class="toc-number">4.2.1.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#返回值："><span class="toc-number">4.2.1.2.</span> <span class="toc-text">返回值：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总结："><span class="toc-number">4.2.1.3.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#简单测试"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">简单测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、mmap-与munmap"><span class="toc-number">4.2.2.</span> <span class="toc-text">2、mmap()与munmap():</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用管理命令"><span class="toc-number">5.</span> <span class="toc-text">常用管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看系统内存状态"><span class="toc-number">5.1.</span> <span class="toc-text">查看系统内存状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pmap"><span class="toc-number">5.2.</span> <span class="toc-text">pmap</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 7
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href="/2019/06/23/深入理解Linux中内存管理/">深入理解linux中内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/屏幕适配/">屏幕适配</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/增量更新/">增量更新</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/apk签名及多渠道打包/">apk签名过程及多渠道</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/android编舞者ChoreoGrapher/">android编舞者ChoreoGrapher</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href="/2019/06/20/FFmpeg命令详解 /">FFmpeg命令详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span><a class="archive-post-title" href="/2019/06/19/android绘制原理/">android绘制原理</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="音视频 ffmpeg"><span class="iconfont-archer">&#xe606;</span>音视频 ffmpeg</span>
    
        <span class="sidebar-tag-name" data-tags="android绘制"><span class="iconfont-archer">&#xe606;</span>android绘制</span>
    
        <span class="sidebar-tag-name" data-tags="android源码 绘制原理 vysn"><span class="iconfont-archer">&#xe606;</span>android源码 绘制原理 vysn</span>
    
        <span class="sidebar-tag-name" data-tags="打包原理"><span class="iconfont-archer">&#xe606;</span>打包原理</span>
    
        <span class="sidebar-tag-name" data-tags="apk打包原理 增量更新"><span class="iconfont-archer">&#xe606;</span>apk打包原理 增量更新</span>
    
        <span class="sidebar-tag-name" data-tags="适配"><span class="iconfont-archer">&#xe606;</span>适配</span>
    
        <span class="sidebar-tag-name" data-tags="linux 虚拟内存 内存管理 c内存模型"><span class="iconfont-archer">&#xe606;</span>linux 虚拟内存 内存管理 c内存模型</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "gagapencil"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


