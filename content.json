{"meta":{"title":"嘻嘻疯子的android小站","subtitle":null,"description":"android开发 学习 工作 生活","author":"gagapencil","url":"https://hesitationpencil.github.io","root":"/"},"pages":[],"posts":[{"title":"apk签名过程及多渠道","slug":"apk签名及多渠道打包","date":"2019-06-20T07:19:14.000Z","updated":"2019-06-20T07:55:23.896Z","comments":true,"path":"2019/06/20/apk签名及多渠道打包/","link":"","permalink":"https://hesitationpencil.github.io/2019/06/20/apk签名及多渠道打包/","excerpt":"","text":"apk签名过程及多渠道公司业务渠道较多共有70多个渠道，打包时间较长，所以抽时间研究一下美团的多渠道打包。本文介绍常见的多渠道打包方式：productFlavors方式，apktool,美团1.0，美团2.0,腾讯 这些方式技术从旧到新，试图说起多渠道打包的脉络。 productFlavorsproductFlavors不用切换项目分支就可以编译调试不同项目版本的APK，并且可以快速打包所有项目版本的APK。例如是开发第三方Android OS的时候，由于要给不同的厂商做定制，并且适配不同的硬件平台，所以发版本的时候，经常要切换项目分支，然后逐个编译APK。关于更多productFlavor介绍参考：productFlavors详细使用 productFlavors多渠道打包具体详情参见：Gradle实战：Android多渠道打包方案汇总 早期的多渠道打包基本上是采用这种方式。首先，在AndroidManifest.xml中添加渠道信息占位符： 1&lt;meta-data android:name=&quot;InstallChannel&quot; android:value=&quot;$&#123;InstallChannel&#125;&quot; /&gt; 然后，通过Gradle Plugin提供的productFlavors标签，添加渠道信息： 12345678productFlavors&#123; &quot;YingYongBao&quot;&#123; manifestPlaceholders = [InstallChannel : &quot;YingYongBao&quot;] &#125; &quot;360&quot;&#123; manifestPlaceholders = [InstallChannel : &quot;360&quot;] &#125;&#125; 这样，Gradle编译生成多渠道包时，会用不同的渠道信息替换AndroidManifest.xml中的占位符。我们在代码中，也就可以直接读取AndroidManifest.xml中的渠道信息了。 但是，这种方式存在一些缺点： 每生成一个渠道包，都要重新执行一遍构建流程，效率太低，只适用于渠道较少的场景。 Gradle会为每个渠道包生成一个不同的BuildConfig.java类，记录渠道信息，导致每个渠道包的DEX的CRC值都不同。一般情况下，这是没有影响的。但是如果你使用了微信的Tinker热补丁方案，那么就需要为不同的渠道包打不同的补丁，这完全是不可以接受的。（因为Tinker是通过对比基础包APK和新包APK生成差分补丁，然后再把补丁和基础包APK一起合成新包APK。这就要求用于生成差分补丁的基础包DEX和用于合成新包的基础包DEX是完全一致的，即：每一个基础渠道包的DEX文件是完全一致的，不然就会合成失败） 针对上述问题市面上出现了很多第三方，其中比较突出的是apktool,mcxiaoke的packer-ng-plugin，美图的walle和腾讯的VasDolly apk签名过程及多渠道方案现市面上存在的多渠道打包方式的原理大都是改apk文件，如此会造成签名验证问题。如此要掌握多渠道，需要先了解apk的签名过程。apk的签名先后有v1,v2,v3三种。 签名相关的基础知识在了解apk的签名方式之前，我们先要了解签名相关的基础知识 数据摘要数据摘要算法是一种能产生特定输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就是原始数据的消息摘要，也称为数据指纹。一般情况下，数据摘要算法具有以下特点： 无论输入数据有多大（长），计算出来的数据摘要的长度总是固定的。例如：MD5算法计算出的数据摘要有128Bit。一般情况下（不考虑碰撞的情况下），只要原始数据不同，那么其对应的数据摘要就不会相同。 同时，只要原始数据有任何改动，那么其数据摘要也会完全不同。即：相同的原始数据必有相同的数据摘要，不同的原始数据，其数据摘要也必然不同。 不可逆性 即只能正向提取原始数据的数据摘要，而无法从数据摘要中恢复出原始数据。著名的摘要算法有RSA公司的MD5算法和SHA系列算法。数字签名和数字证书数字签名和数字证书是成对出现的，两者不可分离（数字签名主要用来校验数据的完整性，数字证书主要用来确保公钥的安全发放）。要明白数字签名的概念，必须要了解数据的加密、传输和校验流程。一般情况下，要实现数据的可靠通信，需要解决以下两个问题： 确定数据的来源是其真正的发送者。 确保数据在传输过程中，没有被篡改，或者若被篡改了，可以及时发现。 而数字签名，就是为了解决这两个问题而诞生的。首先，数据的发送者需要先申请一对公私钥对，并将公钥交给数据接收者。然后，若数据发送者需要发送数据给接收者，则首先要根据原始数据，生成一份数字签名，然后把原始数据和数字签名一起发送给接收者。数字签名由以下两步计算得来： 计算发送数据的数据摘要 用私钥对提取的数据摘要进行加密这样，数据接收者拿到的消息就包含了两块内容： 原始数据内容 附加的数字签名 接下来，接收者就会通过以下几步，校验数据的真实性： 用相同的摘要算法计算出原始数据的数据摘要。 用预先得到的公钥解密数字签名。 对比签名得到的数据是否一致，如果一致，则说明数据没有被篡改，否则数据就是脏数据了 因为私钥只有发送者才有，所以其他人无法伪造数字签名。这样通过数字签名就确保了数据的可靠传输。综上所述，数字签名就是只有发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对发送者发送数据真实性的一个有效证明。 想法虽好，但是上面的整个流程，有一个前提，就是数据接收者能够正确拿到发送者的公钥。如果接收者拿到的公钥被篡改了，那么坏人就会被当成好人，而真正的数据发送者发送的数据则会被视作脏数据。那怎么才能保证公钥的安全性那？这就要靠数字证书来解决了。 数字证书是由有公信力的证书中心（CA）颁发给申请者的证书，主要包含了：证书的发布机构、证书的有效期、申请者的公钥、申请者信息、数字签名使用的算法，以及证书内容的数字签名。 可见，数字证书也用到了数字签名技术。只不过签名的内容是数据发送方的公钥，以及一些其它证书信息。这样数据发送者发送的消息就包含了三部分内容： 原始数据内容 附加的数字签名 申请的数字证书。 接收者拿到数据后，首先会根据CA的公钥，解码出发送者的公钥。然后就与上面的校验流程完全相同了。 所以，数字证书主要解决了公钥的安全发放问题。因此，包含数字证书的整个签名和校验流程如下图所示： V1签名和多渠道打包方案在android 7.0（N）之前是这种。 V1签名机制默认情况下，APK使用的就是V1签名。解压APK后，在META-INF目录下，可以看到三个文件：MANIFEST.MF、CERT.SF、CERT.RSA。它们都是V1签名的产物。 其中，MANIFEST.MF文件内容如下所示： 它记录了APK中所有原始文件的数据摘要的Base64编码,而数据摘要算法就是SHA1。 CERT.SF文件内容如下所示： SHA1-Digest-Manifest-Main-Attributes主属性记录了MANIFEST.MF文件所有主属性的数据摘要的Base64编码。SHA1-Digest-Manifest则记录了整个MANIFEST.MF文件的数据摘要的Base64编码。其余的普通属性则和MANIFEST.MF中的属性一一对应，分别记录了对应数据块的数据摘要的Base64编码。例如：CERT.SF文件中skin_drawable_btm_line.xml对应的SHA1-Digest，就是下面内容的数据摘要的Base64编码。 123Name: res/drawable/skin_drawable_btm_line.xmlSHA1-Digest: JqJbk6/AsWZMcGVehCXb33Cdtrk=\\r\\n 这里要注意的是：最后一行的换行符是必不可少，需要参与计算的。 CERT.RSA文件包含了对CERT.SF文件的数字签名和开发者的数字证书。RSA就是计算数字签名使用的非对称加密算法。 V1签名的详细流程可参考SignApk.java，整个签名流程如下图所示： 整个签名机制的最终产物就是MANIFEST.MF、CERT.SF、CERT.RSA三个文件。 v1校验流程在安装APK时，Android系统会校验签名，检查APK是否被篡改。代码流程是：PackageManagerService.java -&gt; PackageParser.java，PackageParser类负责V1签名的具体校验。整个校验流程如下图所示： 若中间任何一步校验失败，APK就不能安装。 OK，了解了V1的签名和校验流程。我们来看下，V1签名是怎么保证APK文件不被篡改的？首先，如果破坏者修改了APK中的任何文件，那么被篡改文件的数据摘要的Base64编码就和MANIFEST.MF文件的记录值不一致，导致校验失败。其次，如果破坏者同时修改了对应文件在MANIFEST.MF文件中的Base64值，那么MANIFEST.MF中对应数据块的Base64值就和CERT.SF文件中的记录值不一致，导致校验失败。最后，如果破坏者更进一步，同时修改了对应文件在CERT.SF文件中的Base64值，那么CERT.SF的数字签名就和CERT.RSA记录的签名不一致，也会校验失败。那有没有可能继续伪造CERT.SF的数字签名那？理论上不可能，因为破坏者没有开发者的私钥。那破坏者是不是可以用自己的私钥和数字证书重新签名那，这倒是完全可以！ 综上所述，任何对在MANIFEST.MF中有对应数字摘要的文件修改都会导致签名失败，除非重新签名。任何对在MANIFEST.MF文件的修改也会导致签名失败。如此针对v1我们可以从以下3个方面下手避免添加渠道信息后导致签名失败。 添加不被签名包含的文件写入多渠道信息。我们发现在META-INF中新建的文件是不会改变签名结构的，如此可知META-INF中新建文件写入渠道信息，其中美团的第一代打包工具是这样做的。 我们可以通过逆向手段，添加渠道信息。即解压apk，添加渠道信息，重新签名。市面上apktool是这样弄的 修改apk文件。我们发现v1的apk分三部分:内容快，中央目录块和中央结束块(EOCD)，其中EOCD是生成apk时自动加进去的，不受签名保护，如此可在其中添加渠道信息。市面上mcxiaoke的packer-ng-plugin和腾讯的VasDolly是采用这种原理 apktoolApkTool是一个逆向分析工具，可以把APK解开，添加代码后，重新打包成APK，当然这些都是通过脚本实现的。因此，基于ApkTool的多渠道打包方案分为以下几步： 复制一份新的APK通过ApkTool工具，解压APK（apktool d origin.apk）删除已有签名信息添加渠道信息（可以在APK的任何文件添加渠道信息）通过ApkTool工具，重新打包生成新APK（apktool b newApkDir）重新签名经过测试，这种方案完全是可行的。 优点：不需要重新构建新渠道包，仅需要复制修改就可以了。并且因为是重新签名，所以同时支持V1和V2签名。 缺点：ApkTool工具不稳定，曾经遇到过升级Gradle Plugin版本后，低版本ApkTool解压APK失败的情况。生成新渠道包时，需要重新解包、打包和签名，而这几步操作又是相对比较耗时的。经过测试：生成企鹅电竞10个渠道包需要16分钟左右，虽然比Gradle Plugin方案减少很多耗时。但是若需要同时生成上百个渠道包，则需要几个小时，显然不适合渠道非常多的业务场景。 修改apkapktool存在诸多缺点，针对v1我采用的还是添加文件和修改apk来添加渠道信息的。修改文件原理教简单，下面我们重点介绍修改apk apk文件结构修改apk得先知道其结构。APK文件本质上是一个ZIP压缩包，而ZIP格式是固定的，主要由三部分构成，如下图所示： 第一部分是内容块，所有的压缩文件都在这部分。每个压缩文件都有一个local file header，主要记录了文件名、压缩算法、压缩前后的文件大小、修改时间、CRC32值等。 第二部分称为中央目录，包含了多个central directory file header（和第一部分的local file header一一对应），每个中央目录文件头主要记录了压缩算法、注释信息、对应local file header的偏移量等，方便快速定位数据。 最后一部分是EOCD，主要记录了中央目录大小、偏移量和ZIP注释信息等，其详细结构如下图所示： 根据之前的V1签名和校验机制可知，V1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，只要把渠道信息写入到后两块内容就可以通过V1校验，而EOCD的注释字段无疑是最好的选择。 向apk文件结构中写入渠道信息既然找到了突破口，那么基于V1签名的多渠道打包方案就应运而生：在APK文件的注释字段，添加渠道信息。 整个方案包括以下几步： 复制APK 找到EOCD数据块 修改注释长度 添加渠道信息 添加渠道信息长度 添加魔数添加渠道信息后的EOCD数据块如下所示： 这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步： 定位到魔数 向前读两个字节，确定渠道信息的长度LEN 继续向前读LEN字节，就是渠道信息了。 通过16进制编辑器，可以查看到添加渠道信息后的APK（小端模式），如下所示： 6C 74 6C 6F 76 75 7A 68是魔数，04 00表示渠道信息长度为4，6C 65 6F 6E就是渠道信息leon了。0E 00就是APK注释长度了，正好是15。 虽说整个方案很清晰，但是在找到EOCD数据块这步遇到一个问题。如果APK本身没有注释，那最后22字节就是EOCD。但是若APK本身已经包含了注释字段，那怎么确定EOCD的起始位置那？这里借鉴了系统V2签名确定EOCD位置的方案。整个计算流程如下图所示： 整个方案介绍完了，该方案的最大优点就是：不需要解压缩APK，不需要重新签名，只需要复制APK，在注释字段添加渠道信息。每个渠道包仅需几秒的耗时，非常适合渠道较多的APK。 但是好景不长，Android7.0之后新增了V2签名，该签名会校验整个APK的数据摘要，导致上述渠道打包方案失效。所以如果想继续使用上述方案，需要关闭Gradle Plugin中的V2签名选项，禁用V2签名。 V2签名和多渠道打包方案为什么需要V2签名从前面的V1签名介绍，可以知道V1存在两个弊端： MANIFEST.MF中的数据摘要是基于原始未压缩文件计算的。因此在校验时，需要先解压出原始文件，才能进行校验。而解压操作无疑是耗时的。 V1签名仅仅校验APK第一部分中的文件，缺少对APK的完整性校验。因此，在签名后，我们还可以修改APK文件，例如：通过zipalign进行字节对齐后，仍然可以正常安装。 正是基于这两点，Google提出了V2签名，解决了上述两个问题： V2签名是对APK本身进行数据摘要计算，不存在解压APK的操作，减少了校验时间。 V2签名是针对整个APK进行校验（不包含签名块本身），因此对APK的任何修改（包括添加注释、zipalign字节对齐）都无法通过V2签名的校验。关于第一点的耗时问题，这里有一份实验室数据（Nexus 6P、Android 7.1.1）可供参考。 APK安装耗时对比 取5次平均耗时（秒） V1签名APK 11.64 V2签名APK 4.42 可见，V2签名对APK的安装速度还是提升不少的。 V2签名机制不同于V1，V2签名会生成一个签名块，插入到APK中。因此，V2签名后的APK结构如下图所示： APK签名块位于中央目录之前，文件数据之后。V2签名同时修改了EOCD中的中央目录的偏移量，使签名后的APK还符合ZIP结构。 APK签名块的具体结构如下图所示： 首先是8字节的签名块大小，此大小不包含该字段本身的8字节； 其次就是ID-Value序列，就是一个4字节的ID和对应的数据； 然后又是一个8字节的签名块大小，与开始的8字节是相等的；最后是16字节的签名块魔数。 其中，ID为0x7109871a对应的Value就是V2签名块数据。 V2签名块的生成可参考ApkSignerV2，整体结构和流程如下图所示： 首先，根据多个签名算法，计算出整个APK的数据摘要，组成左上角的APK数据摘要集； 接着，把最左侧一列的数据摘要、数字证书和额外属性组装起来，形成类似于V1签名的“MF”文件（第二列第一行）； 其次，再用相同的私钥，不同的签名算法，计算出“MF”文件的数字签名，形成类似于V1签名的“SF”文件（第二列第二行）； 然后，把第二列的类似MF文件、类似SF文件和开发者公钥一起组装成通过单个keystore签名后的v2签名块（第三列第一行）。 最后，把多个keystore签名后的签名块组装起来，就是完整的V2签名块了（Android中允许使用多个keystore对apk进行签名）。 上述流程比较繁琐。简而言之，单个keystore签名块主要由三部分组成，分别是上图中第二列的三个数据块：类似MF文件、类似SF文件和开发者公钥，其结构如下图所示： 除此之外，Google也优化了计算数据摘要的算法，使得可以并行计算，如下图所示： 数据摘要的计算包括以下几步： 首先，将上述APK中文件内容块、中央目录、EOCD按照1MB大小分割成一些小块。 然后，计算每个小块的数据摘要，基础数据是0xa5 + 块字节长度 + 块内容。 最后，计算整体的数据摘要，基础数据是0x5a + 数据块的数量 + 每个数据块的摘要内容。 这样，每个数据块的数据摘要就可以并行计算，加快了V2签名和校验的速度。 V2校验流程Android Gradle Plugin2.2之上默认会同时开启V1和V2签名，同时包含V1和V2签名的CERT.SF文件会有一个特殊的主属性，如下图所示： 该属性会强制APK走V2校验流程（7.0之上），以充分利用V2签名的优势（速度快和更完善的校验机制）。因此，同时包含V1和V2签名的APK的校验流程如下所示： 简而言之：优先校验V2，没有或者不认识V2，则校验V1。 这里引申出另外一个问题：APK签名时，只有V2签名，没有V1签名行不行？经过尝试，这种情况是可以编译通过的，并且在Android 7.0之上也可以正确安装和运行。但是7.0之下，因为不认识V2，又没有V1签名，所以会报没有签名的错误。 OK，明确了Android平台对V1和V2签名的校验选择之后，我们来看下V2签名的具体校验流程（PackageManagerService.java -&gt; PackageParser.java-&gt; ApkSignatureSchemeV2Verifier.java），如下图所示： 其中，最强签名算法是根据该算法使用的数据摘要算法来对比产生的，比如：SHA512 &gt; SHA256。 校验成功的定义是至少找到一个keystore对应的签名块，并且所有签名块都按照上述流程校验成功。 下面我们来看下V2签名是怎么保证APK不被篡改的？ 首先，如果破坏者修改了APK文件的任何部分（签名块本身除外），那么APK的数据摘要就和“MF”数据块中记录的数据摘要不一致，导致校验失败。 其次，如果破坏者同时修改了“MF”数据块中的数据摘要，那么“MF”数据块的数字签名就和“SF”数据块中记录的数字签名不一致，导致校验失败。 然后，如果破坏者使用自己的私钥去加密生成“SF”数据块，那么使用开发者的公钥去解密“SF”数据块中的数字签名就会失败； 最后，更进一步，若破坏者甚至替换了开发者公钥，那么使用数字证书中的公钥校验签名块中的公钥就会失败，这也正是数字证书的作用。 综上所述，任何对APK的修改，在安装时都会失败，除非对APK重新签名。但是相同包名，不同签名的APK也是不能同时安装的。 其实也很简单，原来Android系统在校验APK的数据摘要时，首先会把EOCD的中央目录偏移量替换成签名块的偏移量，然后再计算数据摘要。而签名块的偏移量不就是v2签名之前的中央目录偏移量嘛！！！，因此，这样计算出的数据摘要就和“MF”数据块中的数据摘要完全一致了。具体代码逻辑，可参考ApkSignatureSchemeV2Verifier.java的416 ~ 420行 基于V2签名的多渠道打包方案在上节V2签名的校验流程中，有一个很重要的细节：Android系统只会关注ID为0x7109871a的V2签名块，并且忽略其他的ID-Value，同时V2签名只会保护APK本身，不包含签名块。 因此，基于V2签名的多渠道打包方案就应运而生：在APK签名块中添加一个ID-Value，存储渠道信息。 整个方案包括以下几步： 找到APK的EOCD块 找到APK签名块 获取已有的ID-Value Pair 添加包含渠道信息的ID-Value 基于所有的ID-Value生成新的签名块 修改EOCD的中央目录的偏移量（上面已介绍过：修改EOCD的中央目录偏移量，不会导致数据摘要校验失败） 用新的签名块替代旧的签名块，生成带有渠道信息的APK 实际上，除了渠道信息，我们可以在APK签名块中添加任何辅助信息。 通过16进制编辑器，可以查看到添加渠道信息后的APK（小端模式），如下所示： V3签名和多渠道打包方案在android 9.0(N)引入的 为什么要有v3主要是为了换签名 生成签名的时，可以指定一个有效时间，这个时间默认为 25 年，并且 Google Play 也有硬性规定，上架的 App 签名有效期必须在 2033-10-22 日期之后。所以只要不是手欠修改了这个有效期，在当下这个时刻，是不会有问题，毕竟到现在还没有一款 App 存在 25 年。当然还有可能是公司被收购 需要改签名有些问题不在眼前，却是真实存在的。对于一款上架的 App，最重要的就是用户，而当签名失效之后，我们只能被迫换签名，此时因为签名校验无法通过，就会导致旧用户无法覆盖安装。这些历史用户唯一的选择，就是卸载后重新安装。好在这不仅仅是你我的问题，天塌下来有个子高的顶着，所以别担心，Google 已经着手在解决这个问题了。 v3签名块结构v3版本签名块也分成同样的三部分，与v2不同的是在SignerData部分，v3新增了attr块，其中是由更小的level块组成。每个level块中可以存储一个证书信息。前一个level块证书验证下一个level证书，以此类推。最后一个level块的证书，要符合SignerData中本身的证书，即用来签名整个APK的公钥所属于的证书。两个版本的签名块结构如下： v3验证签名流程因为签名的验证就是发生在一个apk包的安装过程中，所以为了更清楚验证签名的时机，有必要了解整个安装的分类与大致流程。Android安装应用主要有如下四种方式： 系统应用安装：开机时完成，没有安装界面 网络下载的应用安装：通过市场应用完成，没有安装界面 ADB工具安装：没有安装界面 第三方应用安装：通过packageinstall.apk应用安装，有安装界面 但是其实无论通过哪种方式安装都要通过PackageManagerService来完成安装的主要工作，最终在PMS中会去验证签名信息，流程如下 安装过程中如果发现有v3签名块，则必须使用v3签名的验证机制，不能绕过。否则才使用v2签名的验证机制，以此类推。 验证完整性数据完整性校验v3与v2版本相同，原理如下： 签名块包括对apk第一部分，第二部分，第三部分的二进制内容做加密保护，摘要算法以及签名算法。签名块本身不做加密，这里需要特殊注意的是由于第三部分包含了对第二部分的引用偏移，因此如果签名块做了改变，比如在签名过程中增加一种签名算法，或者增加签名者等信息就会导致这个引用偏移发生改变，因此在算摘要的时候需要剔除这个因素要以第三部分对签名块的偏移来做计算。 验证证书v2版本签名验证证书步骤： 利用PublicKey解密Signature，得到SignerData的hash明文 计算SignerData的hash值 两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败 如果是第一次安装，直接将证书保存在应用信息中 如果是更新安装，即设备中原来存在这个应用，验证之前的证书是否与本次解析的证书相同。若相同，则安装成功，否则失败 v3版本签名验证证书步骤：（前三步同v2） 利用PublicKey解密Signature，得到SignerData的hash明文 计算SignerData的hash值 两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败 逐个解析出level块证书并验证，并保存为这个应用的历史证书 如果是第一次安装，直接将证书与历史证书一并保存在应用信息中 如果是更新安装，验证之前的证书与历史证书，是否与本次解析的证书或者历史证书中存在相同的证书，其中任意一个证书符合即可安装 新特性场景举例其实就是当开发者需要更换证书时，即可直接用新证书新的私钥进行签名。不过为了让老应用相信新的证书，则需要用老证书来保证。举个例子，有两个level块：level 1与level 2： level 1放置老证书的信息 level 2中放置新证书的信息以及这段数据的签名 level 2中的签名是由老私钥进行签名的，则需要用老证书的公钥来验证 校验原来的证书与level 1 相同，则相信本次更新的level 2 的证书，即签名APK的证书 完成安装并记录新证书信息 v3多渠道方案略 原理和v2同 参考： https://www.jianshu.com/p/332525b09a88https://github.com/Meituan-Dianping/walle/https://segmentfault.com/a/1190000015554496https://juejin.im/entry/5a586bfaf265da3e2c3808c5https://blog.csdn.net/u010818425/article/details/52319382https://github.com/Tencent/VasDollyhttps://cloud.tencent.com/developer/article/1004884http://picksomething.cn/2018/05/08/Android%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%B9%E9%&gt;87%8F%E6%89%93%E5%8C%85%EF%BC%8C%E6%94%AF%E6%8C%81%E5%8F%8B%E7%9B%9F%E5%92%8C%E7%AC%&gt;AC%E4%B8%89%E6%96%B9%E5%8A%A0%E5%9B%BA/http://twei.site/2016/08/31/MarkdownPad-2-%E6%94%AF%E6%8C%81%E8%A1%A8%E6%A0%BC/","categories":[],"tags":[{"name":"打包原理","slug":"打包原理","permalink":"https://hesitationpencil.github.io/tags/打包原理/"}]},{"title":"apk签名过程及多渠道","slug":"FFmpeg命令详解 ","date":"2019-06-20T07:19:14.000Z","updated":"2019-06-20T07:54:45.146Z","comments":true,"path":"2019/06/20/FFmpeg命令详解 /","link":"","permalink":"https://hesitationpencil.github.io/2019/06/20/FFmpeg命令详解 /","excerpt":"","text":"滤镜解析FFmpeg中filter分为： audio filter video filter Multimedia filter source filter（仅输出） sink filter（仅输入） 详细的滤镜说明参看：https://ffmpeg.org/ffmpeg-filters.html 视频滤镜crop按照特定分辨率裁剪输入视频 截取右下角1/4的区块：crop=in_w/2:in_h/2:in_w/2:in_h/2 scale使用libswscale库完成视频缩放的filter 宽高缩小一半 scale=in_w/2:in_h/2 宽高固定拉伸比例：scale=1400:900::force_original_aspect_ratio=decrease pad视频边界填充 不论输入视频分辨率，统一缩放成1280x720，并且居中展示: scale=1280:720:force_original_aspect_ratio=decrease, pad=1280:720:(1280-in_w)/2:(720-in_h)/2 overlay视频叠加 视频叠加在右下角，各空10px：overlay=main_w-overlay_w-10:main_h-overlay_h-10 rotate视频任意角度旋转 逆时针旋转1/6圆周：rotate=-PI/6 视频一直旋转：rotate=&#39;2*PI*t:ow=hypot(iw,ih):oh=ow&#39; hflip &amp; vflip水平和垂直镜像 edgedetect边缘检测 fps按照指定帧率输出视频帧（丢帧或者复制） drawbox绘制box 半透明框：drawbox=x=10:y=10:w=100:h=100:color=pink@0.5:t=max drawgrid绘制grid（表格） 3x3表格：drawgrid=w=iw/3:h=ih/3:t=2:c=white@0.5 drawtext绘制text，编译ffmpeg需要添加选项--enable-libfreetype 微软雅黑字体：drawtext=fontfile=/Users/xxx/fonts/MsYaHei.ttf:text=&#39;Hello 世界&#39;:x=50: y=500:fontsize=80: fontcolor=white blend &amp; tblend将两帧视频合并为一帧。 thumbnail提取缩略图。 transpose图像转置。 histogram生成每帧的各颜色分量的直方图。 showinfo显示视频帧的参数信息，比如时间戳、采样格式、帧类型等。 1、加字幕​ 命令：ffmpeg -i -filter_complex subtitles=filename=-y ​ 说明：利用libass来为视频嵌入字幕，字幕是直接嵌入到视频里的硬字幕。 2、剪切​ 命令：ffmpeg -i -ss 0 -t 10 -y ​ 说明：ss跟的是起始时间，t为持续时间，上面命令意思为从0秒开始截取10秒的时间。 3、缩放​ 命令： ffmpeg -i -filter_complex scale=320:240 -y ​ 说明：scale参数为宽高。 4、剪裁​ 命令：ffmpeg -i -filter_complex crop=320:240:0:0 -y ​ 说明：其中的 crop=320:240:0:0为裁剪参数，具体含义是 crop=width:height:x:y，其中 width 和 height 表示裁剪后的尺寸，x:y 表示裁剪区域的左上角坐标。 5、加水印命令：ffmpeg -i src.avi -vf “movie=[logo];[in][logo]overlay=100:100[out]”-y ​ 说明：LogoName为图片名，overlay=100:100意义为overlay=x:y，在(x,y)坐标处开始添加水印。 ​ 左上角：overlay=10:10 ​ 右上角：overlay=main_w-overlay_w-10:10 ​ 左下角：overlay=10:main_h-overlay_h-10 ​ 右下角：overlay=main_w-overlay_w-10:main_h-overlay_h-10 6、拼接视频​ 命令： ​ 第一步：ffmpeg -i INPUT -fmpeg OUTPUT ​ 第二步：copy /b INPUT+INPUT OUTPUT ​ 第三步：ffmpeg -i INPUT -f FORMAT OUTPUT ​ 说明：第一步把输入文件转为相同格式，第二步利用copy命令把文件合并，第三步把合并文件转为最终结果视频。 ​ 例：把名为test.avi、test1_2.mp4 两个视频合并为resu.avi。 ​ 第一步：ffmpeg -itest1.avi test1.mpg ​ ffmpeg-i test1_2.mp4 test2.mpg ​ 第二步：copy /btest1.mpg+test2.mpg resu.mpge ​ 第三步：ffmpeg -iresu.mpge -y resu.avi 7、旋转​ 命令： ffmpeg -i -filter_complex transpose=X -y ​ 说明：transpose=1为顺时针旋转90°，transpose=2逆时针旋转90°。 8、镜像​ 上下镜像 ​ 命令：ffmpeg -i src.avi -vf “split[mian][tmp];[tmp]crop=iw:ih/2:0:0,vflip[flip];[mian][flip]overlay=0:H/2”-y GHO.avi ​ 说明：从命令中可以看出crop和vflip在一条流水线上，他们的处理流程如下图所示： 可以利用此filter来做上下颠倒，命令如下： ffmpeg-i src.avi -vf “split [main][tmp]; [tmp] crop=iw:ih:0:0, vflip [flip];[main][flip] overlay=0:0” GHO2.avi 处理效果和 命令ffmpeg -isrc.avi -vf vflip GHO_v_1.avi一样， 这样写只是为了更好的理解filter处理链。 ​ 左右镜像 ​ 命令： ffmpeg -i src.avi-vf “split [main][tmp]; [tmp] crop=iw/2:ih:0:0, hflip [flip]; [main][flip]overlay=W/2:0” GHO_H.avi ​ 说明：流程和上下镜像一样，只是把坐标换了，并且指定用名为hfilp的filter。 ​ 可以利用此filter来做左右颠倒，命令如下： ffmpeg-i src.avi -vf “split [main][tmp ]; [tmp] crop=iw:ih:0:0, hflip [flip];[main][flip] overlay=W:0” GHO_H_1.avi和命令ffmpeg -i src.avi-vf hflip GHO_H_1.avi一样的效果，这样写只是为了更好的理解filter处理链。 ​ 小结：split过滤器把输入分裂为2路输出，crop过滤器为翻转选取图像范围，vflip和hflip过滤器把crop切下的图像翻转（垂直、水平），overlay过滤器指定坐标来贴经过翻转处理的图像。 ​ 9、加黑边​ 命令： ffmpeg -isrc.avi -vf pad=1280:800:0:40:black -y test_pad.avi ​ 说明：pad=width:high:x:y:coler，这里的宽和高指的是结果视频尺寸（包含加黑边的尺寸），XY指的是源视频添加到结果视频所在位置，coler为填充颜色。 10、调音量​ 命令：ffmpeg -i -vol X ​ 说明：不解释","categories":[],"tags":[{"name":"音视频 ffmpeg","slug":"音视频-ffmpeg","permalink":"https://hesitationpencil.github.io/tags/音视频-ffmpeg/"}]},{"title":"apk签名过程及多渠道","slug":"增量更新","date":"2019-06-20T07:19:14.000Z","updated":"2019-06-20T07:54:51.248Z","comments":true,"path":"2019/06/20/增量更新/","link":"","permalink":"https://hesitationpencil.github.io/2019/06/20/增量更新/","excerpt":"","text":"增量更新增量更新 一种不需要重新下载apk，利用新的apk在原有的基础生成patch包进行更新的一种技术。本文重增量更新的作用，原理和使用进行阐述。 原理及作用增量更新就是比较两个apk之间的二进制差异，生成patch包然后打入旧的apk里面从而达到生成新的apk。例如说：第一个版本是3M的apk ，第二个是8M的apk ，生成的patch包可能就在4M左右，甚至更小，但也不是单纯的两个apk相减的差值，有可能两个大小差不多的apk，生成patch包可能在1M左右，这个也是看包里的改动大小。生成的 patch下载到Android设备上跟较低版本的apk合成一个新版本的apk文件，如果不出意外的话，这个生成的apk和你之前做差分的apk是一致的。这么做就会为用户去节省很多的流量，就不会让用户去下载完整的apk，从而提高了用户体验。 使用 利用old.apk和new.apk生成增量文件（patch） 利用old.apk和patch生成new.apk 安装 需要实现增量更新，现在有各种开源的制作与合并差分包的开源库，比如：bsdiff、hdiff等等。因此我们只需要获得源码来使用即可。 增量文件的生成这里利用bsdiff工具做二进制的一个diff和patch了，可以直接下载工具window:https://github.com/cnSchwarzer/bsdiff-win/releases ubuntu:ubuntu sudo apt-get install bsdiff bisdiff算法原理尽可能多的利用old文件中已有的内容看，尽可能少的加入新的内容来构建new文件。通常的做法是对old文件和new文件做子字符串匹配或者使用hash技术，提取公共部分，将new文件中剩余的部分打包成patch包，在patch阶段中，用copying和insertion两个基本操作即可将old文件和patch包合成new文件。 ubuntu编译bisdiff下载ubuntu可自己编译bsdiff工具，先下载bisdiff和bzip2 bsdiff 下载地址： http://www.daemonology.net/bsdiff/ bsdiff 依赖bzip2(zip压缩库) https://nchc.dl.sourceforge.net/project/gnuwin32/bzip2/1.0.5/bzip2-1.0.5-src.zip 下载完后解压 bsdiff: 比较两个文件的二进制数据，生成差分包 bspatch： 合并旧的文件与差分包，生成新文件很显然，bspatch我们需要在Android环境下来执行，而bsdiff 一般会在你的存储服务器当中执行即电脑环境下执行(win或linux) 编译我们在目录下 直接 make 会产生错误需要修改makefile： 12345678910111213install: $&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin.ifndef WITHOUT_MAN $&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1.endif#上面这段makefile片段显然有问题(指令必须以tab开头)#因此需要修改为：install: $&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin .ifndef WITHOUT_MAN $&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1 .endif#也就是在 `.if` 和 `.endif` 前加一个 tab 修改后再来执行make 如果出现找不到bzip2 no file found bzlib.h之类的错误，则需要先安装bzip2： Ubuntu: install libbz2-dev ```1234&gt;&gt; Centos:&gt;&gt; ```yum -y install bzip2-devel.x86_64 Mac: install bzip2```12345678910111213141516171819&gt;&gt; &lt;!--install 不知道填什么，可以使用包管理器进行搜索： --&gt;&gt;&gt; &lt;!-- apt/yum/brew search bzip2 --&gt;如果执行make出现```shellbsdiff.c:(.text.startup+0x2aa): undefined reference to `BZ2_bzWriteOpen&apos;bsdiff.c:(.text.startup+0xcfa): undefined reference to `BZ2_bzWrite&apos;bsdiff.c:(.text.startup+0xe37): undefined reference to `BZ2_bzWrite&apos;bsdiff.c:(.text.startup+0xf80): undefined reference to `BZ2_bzWrite&apos;bsdiff.c:(.text.startup+0xfe1): undefined reference to `BZ2_bzWriteClose&apos;bsdiff.c:(.text.startup+0x1034): undefined reference to `BZ2_bzWriteOpen&apos;bsdiff.c:(.text.startup+0x105c): undefined reference to `BZ2_bzWrite&apos;bsdiff.c:(.text.startup+0x1082): undefined reference to `BZ2_bzWriteClose&apos;bsdiff.c:(.text.startup+0x10d5): undefined reference to `BZ2_bzWriteOpen&apos;bsdiff.c:(.text.startup+0x1100): undefined reference to `BZ2_bzWrite&apos;bsdiff.c:(.text.startup+0x1126): undefined reference to `BZ2_bzWriteClose&apos; 则修改Makefile为： 1234567891011121314151617CFLAGS += -O3 -lbz2PREFIX ?= /usr/localINSTALL_PROGRAM ?= $&#123;INSTALL&#125; -c -s -m 555INSTALL_MAN ?= $&#123;INSTALL&#125; -c -m 444all: bsdiff bspatchbsdiff: bsdiff.c cc bsdiff.c $&#123;CFLAGS&#125; -o bsdiff #增加bspatch: bspatch.c cc bspatch.c $&#123;CFLAGS&#125; -o bspatch #增加install: $&#123;INSTALL_PROGRAM&#125; bsdiff bspatch $&#123;PREFIX&#125;/bin .ifndef WITHOUT_MAN $&#123;INSTALL_MAN&#125; bsdiff.1 bspatch.1 $&#123;PREFIX&#125;/man/man1 .endif bsdiff可以通过如上编译使用，而bspatch则需要在Android工程中使用NDK来进行编译使用，工程地址： https://github.com/HesitationPencil/Study/tree/master/bsdiffdemo","categories":[],"tags":[{"name":"apk打包原理 增量更新","slug":"apk打包原理-增量更新","permalink":"https://hesitationpencil.github.io/tags/apk打包原理-增量更新/"}]},{"title":"apk签名过程及多渠道","slug":"屏幕适配","date":"2019-06-20T07:19:14.000Z","updated":"2019-06-20T07:54:34.477Z","comments":true,"path":"2019/06/20/屏幕适配/","link":"","permalink":"https://hesitationpencil.github.io/2019/06/20/屏幕适配/","excerpt":"","text":"#1.基本概念 ##1.1 px简单说，像素就是表示一个点的RGB颜色；这个点，是数学上的概念，是没有大小的；但是屏幕显示一个像素是需要大小的，具体大小是屏幕尺寸除以屏幕分辨率 ##1.2 屏幕分辨率屏幕分辨率就是屏幕最多能显示多少个像素，如果屏幕最多能显示1080 * 1920个像素，屏幕大小是3 * 5英寸的，那么每个像素占用(3/1080) * (5/1920)的大小。一般情况下屏幕宽高比和像素宽高比是相等的， ##1.2 ppi, dpi屏幕上每英寸上点的数量，我们叫做DPI（dots per inch），因为屏幕上面每个点对应一个像素，所以也有叫PPI；两者大部分情况可以混用，有时候又不一样。当DPI小的时候，每个点的物理尺寸就变大(点的大小理解为 DPI 分之一 英寸；比如DPI是160，每个点就是 1/160 英寸)；所以要解决屏幕颗粒大的问题，提高DPI值就可以了。但DPI提高后，又出现了另外一个问题：同样像素的Bitmap在新的屏幕上看起来小了。假设把DPI从160提高到320，原来160像素在新屏幕上的大小只有原来的一半。 ##1.3 dp,sp 因为在不同dpi下，相同像素下长度不一样，android引入了dp（density independent pixel），sp（Scale-independent Pixel）作为长度单位。简单粗暴直接规定一英寸就是160dp，即1dp=1/160inch;android内部帮我们做了1dp对应多少像素的换算，即（px=dp*(dpi/160)）,即1dp在dpi为160的设备上对应1px，在320dpi上对应2px。如此保证在相同dp下，在不同屏幕密度下显示一样的长度。 sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时，1sp=1dp=1/160inch，而当文字尺寸是“大”或“超大”时，1sp=1sp*scale&gt;1/160inch。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。###1.3.1 dp的缺陷 dp解决了大小一致的问题，没解决比列的问题；如果我们设定控件的宽是160dp，在宽是3inch的屏幕上占比是1/3,在宽是4inch的屏幕上占比是1/4。 不精确；android会将实际dpi进行修正 然后根据density=dpi/160算出density，而px=density * dp；由此可知不是精确的，因为会修正。如实际屏幕密度为321dpi,参考下表知修正后的dpi为480，density为3。 名称 代表分辨率 范围 修正 density mdpi 320x480 120dpi~160dpi 160dpi 1 hdpi 480x800 160dpi~240dpi 240dpi 1.5 xhdpi 720x1280 240dpi~320dpi 320dpi 2 xxhdpi 1080x1920 320dpi~480dpi 480dpi 3 xxxhdpi 480dpi~640dpi 640dp 4 和美工的设计搞不对应。如设计师的图片基准是1080 * 1920，单位是px，如果图标是60px*60px，我们不能直接写60dp * 60dp，要根据屏幕密度换算成相应的dp。#2.宽高限定符适配##2.1好处宽高限定符解决了比列，不精确和 美工设计稿不对应三大问题。##2.2使用做法就是穷举市面上所有的Android手机的宽高像素值： 设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件。比如以480x320为基准分辨率 宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320高度为480，将任何分辨率的高度整分为480份，取值为y1-y480 那么对于800480的分辨率的dimens文件来说，x1=(480/320)1=1.5pxx2=(480/320)*2=3px这个时候，如果我们的UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。这样基本解决了我们的适配问题，而且极大的提升了我们UI开发的效率， ##2.3缺陷 需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。 不适用于sp，当更改系统的字体大小时，字体大小不会改变。因为本质上还是用的px。 包体积大。因为市面上不同宽高的屏幕很多，这里尽可能的适配所有的话，会增大包的体积，采用这种方式包体积一般增大400kb~500kb#3.代码适配##3.1基本原理##3.2常用的百分比库android-support-percent android官方的现已经弃用[AndroidAutoLayout](https://github.com/hongyangAndroid/AndroidAutoLayout)鸿洋的 已停止维护上面两个库都已经停止维护，现在推荐用ConstraintLayout替代。##3.3缺陷 第三方的控件无效 老项目更改繁琐 设计图不匹配#4.最小宽度限定符##4.1 好处 解决了比列 教精确 如果有对应不上的情况，会向下找，这样的话失去了一部分精确性 对应美工设计稿。因为将屏幕分成美工给定的等分##4.2 使用smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。这种机制和上文提到的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。这套方案是上述几种方案中最接近完美的方案。首先，从开发效率上，它不逊色于上述任意一种方案。根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。我们还是以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的diemns文件应该怎么编写呢？这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px*10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。而这种diemns引用，在不同的values-swdp文件夹下的数值是不同的，比如values-sw360dp和values-sw400dp,当系统识别到手机的smallestWidth值时，就会自动去寻找和目标数据最近的资源文件的尺寸。其次，从稳定性上，它也优于上述方案。原生的dp适配可能会碰到Pixel 2这种有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算Pixel 2手机的的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。##4.3 缺陷 不适配android3.2一下版本。其是android3.2以后引入的 包体积过大。大约会增大300kb到800kb左右#5.density适配今日头条开放出来的方案##5.1优点 解决比列问题 解决设计图匹配问题 很精确 不影响包体积##5.2使用###5.2.1原理从dp和px的转换公式 ：px = dp * density 可以看出，如果设计图宽为360dp，想要保证在所有设备计算得出的px值都正好是屏幕宽度的话，我们只能修改 density 的值：##5.3缺陷 如果有用到第三方库控件，则不适用。因为修改了系统的density值之后，整个布局的实际尺寸都会发生改变。#6.其它（待更新） 参考：Android 屏幕适配方案一种极低成本的Android屏幕适配方式Android 目前最稳定和高效的UI适配方案","categories":[],"tags":[{"name":"适配","slug":"适配","permalink":"https://hesitationpencil.github.io/tags/适配/"}]}]}